/*
 * Copyright Â© 2019 Cask Data, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package io.cdap.plugin.gcp.datastore.sink;

import com.google.datastore.v1.Entity;
import com.google.datastore.v1.Key;
import com.google.datastore.v1.PartitionId;
import com.google.datastore.v1.Value;
import com.google.datastore.v1.client.DatastoreHelper;
import com.google.protobuf.ByteString;
import com.google.protobuf.NullValue;
import com.google.protobuf.TextFormat;
import io.cdap.cdap.api.data.format.StructuredRecord;
import io.cdap.cdap.api.data.format.UnexpectedFormatException;
import io.cdap.cdap.api.data.schema.Schema;
import io.cdap.plugin.gcp.datastore.sink.util.IndexStrategy;
import io.cdap.plugin.gcp.datastore.sink.util.SinkKeyType;
import io.cdap.plugin.gcp.datastore.util.DatastorePropertyUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.UnsupportedEncodingException;
import java.lang.reflect.Array;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * Transforms {@link StructuredRecord} to the Google Cloud Datastore {@link Entity}.
 */
public class RecordToEntityTransformer {

  private static final Logger LOG = LoggerFactory.getLogger(RecordToEntityTransformer.class);

  private final String project;
  private final String namespace;
  private final String kind;
  private final SinkKeyType keyType;
  private final String keyAlias;
  private final List<Key.PathElement> ancestors;
  private final Set<String> indexedProperties;
  private final Predicate<String> excludedFromIndex;

  public RecordToEntityTransformer(String project,
                                   String namespace,
                                   String kind,
                                   SinkKeyType keyType,
                                   String keyAlias,
                                   List<Key.PathElement> ancestors,
                                   IndexStrategy indexStrategy,
                                   Set<String> indexedProperties) {
    this.project = project;
    this.namespace = namespace;
    this.kind = kind;
    this.keyType = keyType;
    this.keyAlias = keyAlias;
    this.ancestors = ancestors;
    this.indexedProperties = indexedProperties;
    this.excludedFromIndex = isExcludedFromIndex(indexStrategy);
  }

  public Entity transformStructuredRecord(StructuredRecord record) {
    Key.Builder keyBuilder = Key.newBuilder()
      .setPartitionId(PartitionId.newBuilder().setNamespaceId(namespace).setProjectId(project).build());

    Entity.Builder entityBuilder = Entity.newBuilder();
    List<Schema.Field> fields = Objects.requireNonNull(record.getSchema().getFields(), "Schema fields cannot be empty");

    boolean useAutoGeneratedKey = SinkKeyType.AUTO_GENERATED_KEY == keyType;
    for (Schema.Field field : fields) {
      String fieldName = field.getName();
      if (!useAutoGeneratedKey && keyAlias.equals(fieldName)) {
        entityBuilder.setKey(convertToKey(record, keyBuilder, field));
      } else {
        entityBuilder.putProperties(fieldName, convertToValue(fieldName, field.getSchema(), record,
                                                              excludedFromIndex.test(fieldName)));
      }
    }

    if (useAutoGeneratedKey) {
      entityBuilder.setKey(getAutoGeneratedKey(keyBuilder));
    }
    return entityBuilder.build();
  }

  private Predicate<String> isExcludedFromIndex(IndexStrategy indexStrategy) {
    switch (indexStrategy) {
      case ALL:
        return fieldName -> false;
      case NONE:
        return fieldName -> true;
      case CUSTOM:
        return fieldName -> !indexedProperties.contains(fieldName);
      default:
        throw new IllegalStateException(String.format("Unsupported index strategy '%s'", indexStrategy));
    }
  }

  private Key getAutoGeneratedKey(Key.Builder keyBuilder) {
    if (!ancestors.isEmpty()) {
      keyBuilder.addAllPath(ancestors);
    }
    keyBuilder.addPath(Key.PathElement.newBuilder().setKind(kind));
    return keyBuilder.build();
  }

  @SuppressWarnings("ConstantConditions")
  private Key convertToKey(StructuredRecord record, Key.Builder keyBuilder, Schema.Field field) {
    Schema.Type schemaType = field.getSchema().getType();
    switch (schemaType) {
      case STRING: {
        String strValue = record.get(field.getName());
        if (strValue.isEmpty()) {
          throw new IllegalStateException(
            String.format("Key value cannot be empty. Key field: '%s', Key type: '%s'", field.getName(),
                          keyType.getValue()));
        }
        switch (keyType) {
          case CUSTOM_NAME: {
            if (!ancestors.isEmpty()) {
              keyBuilder.addAllPath(ancestors);
            }
            return keyBuilder.addPath(Key.PathElement.newBuilder()
                                 .setName(strValue).setKind(kind)).build();
          }
          case KEY_LITERAL: {
            return transformKeyLiteralToKey(field, keyBuilder, strValue);
          }
          case URL_SAFE_KEY:
            return transformToUrlSafeKey(field, keyType, strValue);
          default:
            throw new IllegalStateException(
              String.format("Field '%s' of type '%s' cannot be used as a Cloud Datastore key type '%s'",
                            field.getName(), schemaType, keyType.getValue()));
        }
      }
      case INT:
      case LONG: {
        if (keyType == SinkKeyType.CUSTOM_NAME) {
          if (!ancestors.isEmpty()) {
            keyBuilder.addAllPath(ancestors);
          }
          Number numValue = record.get(field.getName());
          return keyBuilder.addPath(Key.PathElement.newBuilder()
                                      .setKind(kind).setId(numValue.longValue()).build()).build();
        }
        throw new IllegalStateException(
          String.format("Key field '%s' of type '%s' is not supported for record type: '%s'",
                        field.getName(), keyType.getValue(), schemaType));
      }
      default:
        String foundType = field.getSchema().isNullable()
          ? "nullable " + field.getSchema().getNonNullable().getType().name()
          : schemaType.name();
        throw new IllegalStateException(
          String.format("Key field '%s' of type '%s' is not supported by key type: '%s'",
                        field.getName(), foundType, keyType.getValue()));
    }
  }

  /**
   * Transforms Url-safe key string to Google Cloud Datastore Key.
   * Url-safe key will represented in the encoded form that can be used as part of a URL.
   * For example: partition_id+%7B%0A++project_id%3A+%22test-project%22%0A++namespace_id%3A+% ...
   * <p/>
   * Note: Defined Project, Namespace, Kind must match extracted Project, Namespace, Kind accordingly.
   *
   * @param field      schema field with key value
   * @param keyType    type of key assigned to entities
   * @param urlSafeKey Url-safe key string
   * @return complete Google Cloud Datastore Key
   */
  private Key transformToUrlSafeKey(Schema.Field field, SinkKeyType keyType, String urlSafeKey) {
    Key.Builder builder = Key.newBuilder();
    try {
      String utf8Str = URLDecoder.decode(urlSafeKey, StandardCharsets.UTF_8.name());
      TextFormat.merge(utf8Str, builder);
    } catch (UnsupportedEncodingException e) {
      throw new IllegalStateException("Unexpected decoding exception", e);
    } catch (TextFormat.ParseException e) {
      throw new IllegalArgumentException("Could not parse key", e);
    }
    Key key = builder.build();
    List<Key.PathElement> pathElements = key.getPathList();
    Key.PathElement keyElement = pathElements.get(pathElements.size() - 1);

    if (!Objects.equals(project, key.getPartitionId().getProjectId())) {
      throw new IllegalArgumentException(
        String.format("%s projectId must be equal to defined projectId. Key field: '%s', " +
                        "Expected: '%s', Received: '%s'",
                      keyType.getValue(), field.getName(), project, key.getPartitionId().getProjectId()));
    } else if (!Objects.equals(namespace, key.getPartitionId().getNamespaceId())) {
      throw new IllegalArgumentException(
        String.format("%s namespace must be equal to defined namespace. Key field: '%s', " +
                        "Expected: '%s', Received: '%s'",
                      keyType.getValue(), field.getName(), namespace, key.getPartitionId().getNamespaceId()));
    } else if (!Objects.equals(kind, keyElement.getKind())) {
      throw new IllegalArgumentException(
        String.format("%s kind must be equal to defined kind. Key field: '%s', " +
                        "Expected: '%s', Received: '%s'",
                      keyType.getValue(), field.getName(), kind, keyElement.getKind()));
    }
    return key;
  }

  /**
   * Transforms Key Literal string to Google Cloud Datastore Key.
   * Key Literal string format: <i>key(kind_1, identifier_1, kind_2, identifier_2, [...])</i>.
   * <p/>
   * Example of key literal string: <i>"key(kind_1, 'stringId', kind_2, 100)"</i>
   * <p/>
   * Extracted kind: <i>kind_2</i>
   * <br/>
   * Extracted identifier: <i>100</i>
   * <br/>
   * Extracted Ancestor: <i>key(kind_1, 'stringId')</i>
   * <p/>
   * Note: Kind set to KeyFactory must match extracted Kind.
   *
   * @param field      schema field with key value
   * @param keyBuilder Key builder
   * @param keyLiteral Key Literal string
   * @return complete Google Cloud Datastore Key
   */
  private Key transformKeyLiteralToKey(Schema.Field field, Key.Builder keyBuilder, String keyLiteral) {
    List<Key.PathElement> pathElements = DatastorePropertyUtil.parseKeyLiteral(keyLiteral);
    LOG.trace("Key Literal '{}' path elements: {}", keyLiteral, pathElements);
    if (pathElements.isEmpty()) {
      throw new IllegalArgumentException(String.format("Field '%s' value has unexpected Key Literal format: '%s'",
                                                       field.getName(), keyLiteral));
    }

    Key.PathElement keyElement = pathElements.get(pathElements.size() - 1);
    LOG.trace("Detected keyElement: '{}'", keyElement);
    if (!kind.equals(keyElement.getKind())) {
      throw new IllegalArgumentException(
        String.format("Received Key Literal kind '%s' must match defined kind '%s'. Field '%s', key literal: '%s'",
                      keyElement.getKind(), kind, field.getName(), keyLiteral));
    }

    keyBuilder.addAllPath(pathElements);
    return keyBuilder.build();
  }

  @SuppressWarnings("ConstantConditions")
  private Value convertToValue(String fieldName, Schema fieldSchema, StructuredRecord record,
                               boolean excludeFromIndex) {
    if (record.get(fieldName) == null) {
      return Value.newBuilder()
        .setNullValue(NullValue.NULL_VALUE)
        .setExcludeFromIndexes(excludeFromIndex)
        .build();
    }

    Schema.LogicalType logicalType = fieldSchema.getLogicalType();
    if (logicalType != null) {
      switch (logicalType) {
        case TIMESTAMP_MILLIS:
        case TIMESTAMP_MICROS:
          ZonedDateTime ts = getValue(record::getTimestamp, fieldName, logicalType.getToken(), ZonedDateTime.class);
          return DatastoreHelper.makeValue(Date.from(ts.toInstant()))
            .setExcludeFromIndexes(excludeFromIndex)
            .build();
        //write datetime value as string - this will be handled by the next block
        case DATETIME:
          break;
        default:
          throw new IllegalStateException(
            String.format("Record type '%s' is not supported for field '%s'", logicalType.getToken(), fieldName));
      }
    }

    Schema.Type fieldType = fieldSchema.getType();
    switch (fieldType) {
      case STRING:
        String stringValue = getValue(record::get, fieldName, fieldType.toString(), String.class);
        return DatastoreHelper.makeValue(stringValue).setExcludeFromIndexes(excludeFromIndex).build();
      case INT:
      case LONG:
        Number longValue = getValue(record::get, fieldName, fieldType.toString(), Number.class);
        return DatastoreHelper.makeValue(longValue.longValue()).setExcludeFromIndexes(excludeFromIndex).build();
      case FLOAT:
      case DOUBLE:
        Number doubleValue = getValue(record::get, fieldName, fieldType.toString(), Number.class);
        return DatastoreHelper.makeValue(doubleValue.doubleValue()).setExcludeFromIndexes(excludeFromIndex).build();
      case BOOLEAN:
        Boolean booleanValue = getValue(record::get, fieldName, fieldType.toString(), Boolean.class);
        return DatastoreHelper.makeValue(booleanValue).setExcludeFromIndexes(excludeFromIndex).build();

      case BYTES:
        byte[] byteArray = getValue(record::get, fieldName, fieldType.toString(), byte[].class);
        return DatastoreHelper.makeValue(ByteString.copyFrom(byteArray))
          .setExcludeFromIndexes(excludeFromIndex).build();
      case RECORD:
        StructuredRecord nestedRecord = getValue(record::get, fieldName, fieldType.toString(), StructuredRecord.class);
        Entity.Builder nestedBuilder = Entity.newBuilder();
        Objects.requireNonNull(fieldSchema.getFields(), "Nested Schema fields cannot be empty").forEach(
          nestedField -> nestedBuilder.putProperties(nestedField.getName(),
                                           convertToValue(nestedField.getName(), nestedField.getSchema(),
                                                          nestedRecord, excludeFromIndex)));
        return DatastoreHelper.makeValue(nestedBuilder.build()).setExcludeFromIndexes(excludeFromIndex).build();
      case ARRAY:
        Schema elementSchema = Schema.recordOf("arrayElementSchema",
                                               Schema.Field.of(fieldName, fieldSchema.getComponentSchema()));

        Collection<Object> arrayValues = toCollection(fieldName, fieldType, record.get(fieldName));
        List<Value> values = arrayValues.stream()
          .map(value -> {
            // TODO CDAP-15727 - remove wrap into record
            // Wrap array element into record to be able to re-use convertToValue method type conversion logic
            // because StructuredRecord has different methods to extract value based on schema type.
            // For example: record.get(fieldName) is used for most of the values,
            // record.getTimestamp(fieldName) is used for timestamp values.
            StructuredRecord structuredRecord = StructuredRecord.builder(elementSchema)
              .set(fieldName, value)
              .build();
            return convertToValue(fieldName, elementSchema.getField(fieldName).getSchema(),
                                  structuredRecord, false);
          })
          .collect(Collectors.toList());

        // According to Datastore rule: list cannot be excluded from indexes
         return DatastoreHelper.makeValue(values).build();
      case UNION:
        // simple UNION type
        if (fieldSchema.isNullable()) {
          return convertToValue(fieldName, fieldSchema.getNonNullable(), record, excludeFromIndex);
        }
        // complex UNION type
        for (Schema unionSchema : fieldSchema.getUnionSchemas()) {
          try {
            return convertToValue(fieldName, unionSchema, record, excludeFromIndex);
          } catch (UnexpectedFormatException | IllegalStateException e) {
            // if we couldn't convert, move to the next possibility
          }
        }
        throw new IllegalStateException(
          String.format("Field '%s' is of unexpected type '%s'. Declared 'complex UNION' types: %s",
                        fieldName, record.get(fieldName).getClass().getSimpleName(), fieldSchema.getUnionSchemas()));
      default:
        throw new IllegalStateException(
          String.format("Record type '%s' is not supported for field '%s'", fieldType.name(), fieldName));
    }
  }

  private <T> T getValue(Function<String, T> valueExtractor, String fieldName, String fieldType, Class<T> clazz) {
    T value = valueExtractor.apply(fieldName);
    if (clazz.isAssignableFrom(value.getClass())) {
      return clazz.cast(value);
    }
    throw new UnexpectedFormatException(
      String.format("Field '%s' is not of expected type '%s'", fieldName, fieldType));
  }

  /**
   * Transforms given value to {@link Collection<Object>}, fails if given value is not a collection or array.
   *
   * @param fieldName field name
   * @param fieldType field type
   * @param value value to be casted to {@link Collection<Object>}
   * @return instance of {@link Collection<Object>}
   * @throws UnexpectedFormatException in case if given value is not a collection or array
   */
  @SuppressWarnings("unchecked")
  private Collection<Object> toCollection(String fieldName, Schema.Type fieldType, Object value) {
    Function<String, Collection> valueExtractor = name -> {
      throw new UnexpectedFormatException(
        String.format("Field '%s' of type '%s' has unexpected value '%s'", name, fieldType, value));
    };

    if (value instanceof Collection) {
      valueExtractor = name -> (Collection<?>) value;
    } else if (value.getClass().isArray()) {
      valueExtractor = name -> convertToObjectCollection(value);
    }
    return getValue(valueExtractor, fieldName, fieldType.toString(), Collection.class);
  }

  private Collection<Object> convertToObjectCollection(Object array) {
    Class ofArray = array.getClass().getComponentType();
    if (ofArray.isPrimitive()) {
      List<Object> list = new ArrayList<>();
      int length = Array.getLength(array);
      for (int i = 0; i < length; i++) {
        list.add(Array.get(array, i));
      }
      return list;
    } else {
      return Arrays.asList((Object[]) array);
    }
  }
}
